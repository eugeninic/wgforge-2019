## Задание

Дан односвязный список. Есть указатель на один из его элементов. Требуется удалить за О(1)  этот элемент из списка. Достаточно только описания алгоритма.

## Решение

Структура элемента:

```python
class Node:
    def __init__(self, key):
        self.key = key
        self.next = None
```

Обычно для удаления текущего элемента в односвязном списке изменяется указатель `next` у предыдущего элемента, чтобы он указывал на следующий за текущим элемент. Однако, так как указателя на предыдущий элемент нет, невозможно в нём изменить `next` указатель (если дан указатель на начало, то можно, но за `O(n)`) и удалить текущий элемент.

Поэтому давайте поменяем значение текущего элемента со следующим.

Таким образом уже необходимо удалить следующий элемент, а сделать это можно,как рассказано выше, указав `next` текущего элемента на элемент, следующий за удаляемым. Таким образом доступа к следующему за текущим элементом не будет, т.е. он будет удалён.

Решение будет выглядить следующим образом:

```python
# class Node:
#     def __init__(self, key):
#         self.key = key
#         self.next = None

def remove_node(node: Node):
    node.key = node.next.key
    node.next = node.next.next
```

Но, если удаляемый элемент последний, то программа ломается.

Тут в зависимости от того, как реализован список, решение может быть, а может и не быть.
1. Список просто заканчивается, тогда `next` указатель у удаляемого элемента равен `NULL`
   
   В этом случае задачу решить нельзя, потому что, заменив текущий элемент на `NULL`, на него всё равно будет ссылаться предыдущий.
2. Как рассказывалось на лекции, можно (здесь даже нужно) использовать _элемент заглушку_ в конце списка, т. е. список заканчивается не на `NULL`, а на какой-то определённый элемент.
   
   В этом случае задачу можно решить (однако нужно подумать о проверке: является ли текущий элемент _элементом заглушкой_)
