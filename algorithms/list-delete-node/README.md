## Задание

Дан односвязный список. Есть указатель на один из его элементов. Требуется удалить за О(1)  этот элемент из списка. Достаточно только описания алгоритма.

## Решение

Обычно для удаления текущего элемент в односвязном списке изменяется указатель  _next_ с предыдущего элемента, чтобы он указывал на следующий за текущим элемент. Однако, так как у нас нет указателя на предыдущий элемент, мы не можем изменить в нём _next_ указатель (если дан указатель на голову, то можем, но за `O(N)`) и удалить текущий элемент.

Поэтому давайте поменяем значение текущего элемента со следующим.

Таким образом уже необходимо удалить следующий элемент, а сделать это просто: как рассказано выше, указать на элемент следующий за удаляемым.

То есть решение будет выглядить следующим образом:

```python
# class Node:
#     def __init__(self, key):
#         self.key = key
#         self.next = None

def remove_node(node: Node):
    node.key = node.next.key
    node.next = node.next.next
```

Но, если удаляемый элемент последний, то программа ломается.

Тут в зависимости от того, как реализован список, решение может быть, а может и не быть.
1. Список просто заканчивается, когда _next_ указатель равен `NULL`
2. Как рассказывалось на лекции, можно (здесь даже нужно) использовать _элемент заглушку_ в конце списка, т. е. список заканчивается не на `NULL`, а на какой-то заданный нами элемент
   
В первом случае задачу решить нельзя, потому что мы не можем заменить текущий элемент на `NULL`, предыдущий всё равно на него будет ссылаться.

Во втором случае задачу можно решить, но нужно быть внимательным. Тут проблема может быть в том, как проверяется конец списка.

Если  элемент _заглушка_ хранится как объект, то при таком переприсваивании данных (если удаляем последний элемент) _заглушкой_ уже будет другой объект и при сравнение они будут не равны. Это можно решить, сравнивая их по значению, но это более дорогостоящая операция.
