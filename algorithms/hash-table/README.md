## Задание 

Предположим, что в реализации хеш-таблицы методом цепочек мы решили хранить каждый список отсортированным. Как это повлияет на время работы поиска существующего ключа, поиска отсутствующего ключа, добавления и удаление ключа?

## Решение

Cложность работы хеш-функции `O(1)`, поэтому итоговая сложность зависит от реализации метода цепочек.

Поэтому задачу можно свести к сравнению отсортированного и неотсортированного списка или массива (в зависимости от того, как представить список). 

### Изначальные асимпотики:

---

#### LinkedList

| Operation | Best | Worst | Average |
| :---: | :---: | :---: | :---: |
| Search | O(1) | O(N) | O(N) |
| Update | O(1) | O(N) | O(N) |
| Insert | O(1) | O(1) | O(1) |
| Delete | O(1) | O(1) | O(1) |
| Indexing | O(1) | O(N) | O(N) |

#### DynamicArray (not sorted)

| Operation | Best | Worst | Average |
| :---: | :---: | :---: | :---: |
| Search | O(1) | O(N) | O(N) |
| Update | O(1) | O(N) | O(N) |
| Insert | O(1) | O(N) | O(N) |
| Delete | O(1) | O(N) | O(N) |
| Indexing | O(1) | O(1) | O(1) |

##### Примечание

Сложность для добавления и удаления элемента указана без поиска. 

Далее сложность вставки - это сложность поиска + сложность вставки.

---


Для решения этой задачи важно, каким образом будет представлен наш список, а точнее будет ли он поддерживать индексацию.

В общем случае в чём преимущество отсортированных данных?

Появляется какая-то структура хранения, которую можно использовать. Самый яркий пример - это бинарный поиск. Он здесь и пригодится.

### 1.  LinkedList or DoubleLinkedList

Так как индексация в _LinkedList_ за `O(n)`, то применять здесь бинарный поиск не получится (сложность вырастет до `O(n log(n))`.

 Поэтому асимптотика функций не меняется. Возможно, удобнее проводить поиск, потому что необязательно проходить по всему списку.Но все преимущества теряются, когда мы начинаем добавлять ключи в порядке возрастания (убывания - в зависимости от упорядочивания данных по возрастанию или убыванию).

В таком случае имеем следующую итоговую асимптотику.

| Operation | Best | Worst | Average |
| :---: | :---: | :---: | :---: |
| Search | O(1) | O(N) | O(N) |
| Update | O(1) | O(N) | O(N) |
| Insert | O(1) | O(1) | O(1) |
| Delete | O(1) | O(1) | O(1) |
| Indexing | O(1) | O(N) | O(N) |

#### Вывод

В асимптотике ничего не изменилось.

Отсортированный список не даёт большого выиграша по проиводительности по сравнению с неотсортированным. Даёт небольшое ускорение поиска - отсюда соответственно удаления и добавления, но в худшем и среднем случае - это всё равно `O(1)`.


### 2. Array

А вот преимущества у отсортированного массива уже есть. 

Так как массив поддерживает индексацию за `O(1)`, то здесь можно воспользоваться бинарным поиском, таким образом снижая асимптотику поиска до `O(log(n))`.

То есть асимптотика обновления и поиска элемента снижается c `O(n)` до `O(n log(n))`.

В тоже время асимптотика вставки и удаления не меняется. Хотя становится чуть быстрее. Если раньше сначала нужно было найти элемент за `O(n)`, а затем ещё за `O(n)` вставить или удалить (общая сложность `O(n)`), то теперь на операцию поиска элемента необходимо затратить `O(log(n))`, но на операцию вставки всё равно `O(n)` (итоговая сложность `O(log(n) + n) = O(n)`).

То есть теперь асимптотика следующая:

| Operation | Best | Worst | Average |
| :---: | :---: | :---: | :---: |
| Search | O(1) | O(log(N)) | O(log(N)) |
| Update | O(1) | O(log(N)) | O(log(N)) |
| Insert | O(1) | O(N) | O(N) |
| Delete | O(1) | O(N) | O(N) |
| Indexing | O(1) | O(1) | O(1) |

#### Вывод

Асимптотика функций обновления и поиска улучшилась.

Отсортированный массив имеет преимущества перед неотсортированным.

Если в хеш таблице будет проводится много операций обновления и поиска, то лучше задуматься об использовании отсортированного массива.

### Общий вывод

Если вы знаете, что в вашу хеш таблицу будет очень много запросов на обновления или поиск, то лучше подумать об использований отсортированного массива, который позволит значительно ускорить эти операции.

