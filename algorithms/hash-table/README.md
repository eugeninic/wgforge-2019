## Задание 

Предположим, что в реализации хеш-таблицы методом цепочек мы решили хранить каждый список отсортированным. Как это повлияет на время работы поиска существующего ключа, поиска отсутствующего ключа, добавления и удаление ключа?

## Ответ

Задача сводится к оценке отсортированного и неотсортированного списка или массива (в зависимости от того, как представить списик).

Изначальные асимпотики:

---

#### LinkedList

| Operation | Best | Worst | Average |
| :---: | :---: | :---: | :---: |
| Search | O(1) | O(N) | O(N) |
| Update | O(1) | O(N) | O(N) |
| Insert | O(1) | O(1) | O(1) |
| Delete | O(1) | O(1) | O(1) |
| Indexing | O(1) | O(N) | O(N) |

#### DynamicArray (not sorted)

| Operation | Best | Worst | Average |
| :---: | :---: | :---: | :---: |
| Search | O(1) | O(N) | O(N) |
| Update | O(1) | O(N) | O(N) |
| Insert | O(1) | O(N) | O(N) |
| Delete | O(1) | O(N) | O(N) |
| Indexing | O(1) | O(1) | O(1) |

##### Примечание

Сложность для добавления и удаления элемента указана без поиска. В нашем случае сложность вставки - это сложность поиска + сложность вставки.

---


Здесь важно, каким образом будет представлен наш список, а точнее будет ли он поддерживать индексацию (массив).

В общем случае в чём преимущество отсортированных данных?

Появляется какая-то структура хранения, которую можно использовать. Самый яркий пример - это бинарный поиск. Он здесь и пригодится.

### 1.  LinkedList or DoubleLinkedList

Так как индексация в _LinkedList_ за `O(n)`, то применять здесь бинарный поиск не получится (сложность вырастет до `O(n log(n))`.

 Поэтому асимптотика функций не меняется. Возможно, удобнее проводить поиск, потому что необязательно проходить по всему списку, но всё ломается, когда мы начинаем добавлять ключи в порядке возрастания.

В таком случае имеем следующую асимптотику.

| Operation | Best | Worst | Average |
| :---: | :---: | :---: | :---: |
| Search | O(1) | O(N) | O(N) |
| Update | O(1) | O(N) | O(N) |
| Insert | O(1) | O(1) | O(1) |
| Delete | O(1) | O(1) | O(1) |
| Indexing | O(1) | O(N) | O(N) |

#### Вывод

В асимптотике ничего не изменилось.

Отсортированный список не выигрывает у неотсортированного.

Особо смысла его использовать нет.


### 2. Array

А вот преимущества у отсортированного массива уже есть. 

Так как массив поддерживает индексацию за `O(1)`, то здесь можно воспользоваться бинарным поиском, таким образом снижая асимптотику поиска до `O(log(N))`.

То есть асимптотика обноления и поиска элемента снижается c `O(n)` до `O(n log(n))`.

В тоже время асимптотика вставки и удаления не меняется. Хотя становится чуть быстрее. Если раньше сначала нужно было найти элемент за `O(n)`, а затем ещё за `O(n)` вставить или удалить (общая сложность `O(n)`), то теперь на операцию поиска элемента необходимо `O(log(n))` (итоговая сложность `O(log(n) + n) = O(n)`).

То есть теперь асимптотика следующая:

| Operation | Best | Worst | Average |
| :---: | :---: | :---: | :---: |
| Search | O(1) | O(log(N)) | O(log(N)) |
| Update | O(1) | O(log(N)) | O(log(N)) |
| Insert | O(1) | O(N) | O(N) |
| Delete | O(1) | O(N) | O(N) |
| Indexing | O(1) | O(1) | O(1) |

#### Вывод

Асимптотика функций обновления и поиска уменьшилась.

Отсортированный массив имеет преимущества над неотсортированным.

### Общий вывод

Если вы знаете, что в вашу хеш таблицу будет очень много запросов на обновления или поиск, то лучше подумать об использований отсортированного массива, который позволит значительно ускорить эти операции.
