## Задание 

Рассмотрим односвязный список. Если идти от его начала по указателям на следующий элемент, то мы дойдем до хвоста списка - когда указатель не будет ни на что указывать. Однако, если где-то в списке есть петля (какой-то указатель ссылается на один из  предыдущих элементов), то конца списка мы не достигнем. Требуется проверить спикок на наличие петель за О(количество элементов) и О(1) памяти. Длина списка само собой заранее не известна. Достаточно только описания алгоритма.

## Решение

Решать задачу будем с помощью двух указателей с разнозными _"скоростями"_. Это `O(1)` по памяти.

Обозначим указатели так: _slow_ и _fast_.

_slow_ указатель будет перемещаться на один элемент, а _fast_ - на два в один и тот же промежуток времени.

### Если цикла нет

Если цикла нет, то _fast_ указатель просто дойдёт до конца и станет равным `NULL`.

То есть `fast == NULL`, соответственно цикла в списке нет.

### Цикл есть

Если цикл есть, то мы узнаем об этом, если `slow == fast`.

Рано или поздно два указателя попадут в цикл и будут там перемещаться. 

Теперь давайте докажем, что _fast_ указатель обязательно догонит _slow_.

Заметим, что на каждой итерации расстояние между _fast_ и _slow_ указателями уменьшается на 1, потому что _fast_ проходит 2 элемента в то время, как _slow_ всего 1. Таким образом через `n = расстояние между указателями` итераций расстояние между _fast_ и _slow_ указателями станет равными нулю.

В этом случае `fast == slow`. Это значит это в списке есть цикл.

### Реализация

```cpp
/*
struct Node {
    int value;
    Node* next;
    Node(int value): val(value), next(NULL) {}
}
*/

bool hasCycle(Node* head) {
    if (head == NULL || head->next == NULL) {
        return false;
    }
    Node* slow = head;
    Node* fast = head->next; //  head->next in order to pass first iteration of while loop
    while (fast->next && fast->next->next) {
        if (slow == fast) {
            return true;
        }
        fast = fast->next->next;
        slow = slow->next;
    }
    return false;
}
```