## Задание 

Рассмотрим односвязный список. Если идти от его начала по указателям на следующий элемент, то мы дойдем до хвоста списка - когда указатель не будет ни на что указывать. Однако, если где-то в списке есть петля (какой-то указатель ссылается на один из  предыдущих элементов), то конца списка мы не достигнем. Требуется проверить спикок на наличие петель за О(количество элементов) и О(1) памяти. Длина списка само собой заранее не известна. Достаточно только описания алгоритма.

## Решение

Решать задачу будем с помощью двух указателей с разными _"скоростями"_ ([_алгоритм Флойда поиска цикца_, ещё одно название _Черепаха и заяц_](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BD%D0%B0%D1%85%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F_%D1%86%D0%B8%D0%BA%D0%BB%D0%B0#%D0%A7%D0%B5%D1%80%D0%B5%D0%BF%D0%B0%D1%85%D0%B0_%D0%B8_%D0%B7%D0%B0%D1%8F%D1%86)). Затраты по памяти в таком случае `O(1)`.

Обозначим указателя: _slow_ и _fast_.

_slow_ указатель будет перемещаться на один элемент, а _fast_ - на два в один и тот же промежуток времени.

### Если цикла нет

Если цикла нет, то _fast_ указатель просто дойдёт до конца и станет равным `NULL`.

То есть `fast == NULL`, соответственно цикла в списке нет.

### Если цикл есть

Если цикл есть, то мы узнаем об этом, если `slow == fast`.

Рано или поздно два указателя попадут в цикл и будут там перемещаться. 

Теперь давайте докажем, что _fast_ указатель обязательно догонит _slow_.

Заметим, что на каждой итерации расстояние между _fast_ и _slow_ указателями уменьшается на 1, потому что _fast_ проходит 2 элемента в то время, как _slow_ всего 1. Таким образом через `n = расстояние между указателями` итераций расстояние между _fast_ и _slow_ указателями станет равными нулю.

В этом случае `fast == slow`. Это значит это в списке есть цикл.

### Реализация

```cpp
/*
struct Node {
    int value;
    Node* next;
    Node(int value): val(value), next(NULL) {}
}
*/

bool hasCycle(Node* head) {
    if (head == NULL || head->next == NULL) {
        return false;
    }
    Node* slow = head;
    Node* fast = head->next; 
    while (fast->next && fast->next->next) {
        if (slow == fast) {
            return true;
        }
        fast = fast->next->next;
        slow = slow->next;
    }
    return false;
}
```