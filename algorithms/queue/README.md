# Очередь на двух стеках

1. [Обычная очередь на двух стека](#Очередь-на-двух-стеках)
2. [Интересная реализация очереди на двух стеках](#Интересная-реализация-очереди-на-двух-стеках)

## Очередь на двух стеках

Один из вариантов реализации очереди - реализация очереди на двух стеках.

Пусть у нас есть два стека, назовём их `input` стек и `output` стек. 


`input` стек используется для `push` операций. Все элементы, которые добавляются в нашу очередь,  сразу попадают в `input` стек.


`output` стек используется для `pop` операций. Все элементы, которые удаляются из очереди,  удаляются именно из `output` стека.

Если `output` стек пустой (всё изначально добавляется в `input`, здесь ничего нет), то все элементы из стека `input` удаляются и помещаются в `output`. Затем снова все элементы попадают в `input` стек, пока `output` стек не опустошится. То есть при каждой `pop` операции проверяется наличие элементов в `output` стеке, если их там нет, то все элементы из `input` стека перемещаются в `output` стек.

#### Иллюстрация

Здесь левый стек - `input`, правый - `output`.

![](https://i.stack.imgur.com/1YfMo.png)


#### LIFO vs FIFO

Организация очереди - `FIFO`.

Изначально стек организуется как `LIFO`, но после удаления элементов из `input` стека и добавления в `output` стек, порядок хранения меняется на обратный, и при извлечении из `output` стека элементы извлекаются по времени их добавления (_first-in-first-out_), получаем `FIFO`.

#### Реализация


## Интересная реализация очереди на двух стеках

В очереди на двух стеках можно реализовать операции поиска максимума и минимума за `O(1)`.

Для этого необходимо добавить дополнительное поле, которое будет хранить максимальное (минимальное) значение во входном стеке, а также ещё один стек (можно не добавлять, а хранить всё в выходном стеке), который будет хранить текущий максимум (минимум) в выходном стеке.

Тогда, зная минимум во входном и выходном стеках, находим минимум между ними и возвращаем (асимптотика `O(1)`), однако в худшем случае потребуется в два раза больше памяти (если элементы буду добавляться в порядке возрастания (убывания) для поиска минимума (максимума)).

#### Реализация