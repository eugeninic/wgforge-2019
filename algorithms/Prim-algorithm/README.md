### Задача

Модифицировать алгоритм Прима из лекции так,
чтобы он имел сложность не хуже, чем:
1) O(E log V)
2) O(E + V log V)

### Решение


В общем алгоритм Прима для построения минимального остовного дерева заключается в следующем:

Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшей стоимостью. Найденное ребро и соединяемые им две вершины образуют дерево. Затем, рассматриваются рёбра графа, один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.

_Важно:_ граф должен быть связным и неориентированным.

#### 1) Решение за _O(E log(V))_

Здесь для выбора ребра с наименьшей стоимостью будем использовать _Binary Heap_.

Используем алгоритм из лекции с ленивым удалением.

##### Сложность

Сложность такого алгоритма, как было доказано, _O(E log V)_, потому что _E_ раз происходит добавление и удаление в случае такого алгоритма.

##### Code

```python
def binary_heap_mst(graph):
    heap = []
    mst = set()
    edges = []
    tree_weight = 0
    next_vert = next(iter(graph.keys()))
    mst.add(next_vert)
    while len(mst) < len(graph):
        v = next_vert
        for vert, weight in graph[v]:
            heapq.heappush(heap, (weight, v, vert))

        while heap[0][2] in mst:
            heapq.heappop(heap)

        weight, v1, v2 = heap[0]
        heapq.heappop(heap)
        next_vert = v2
        mst.add(v2)
        edges.append((v1, v2))
        tree_weight += weight
 
    return edges, tree_weight
```


#### 2) Решение за _O(E + V log V)_

Здесь для выбора ребра с наименьшей стоимостью будем использовать _Fibonacci Heap_.

В алгоритме сначала потребуется инициализировать все вершины с весом равным бесконечности (очень большим, чтобы был больше веса любого из ребёр). Сложность данной операции _O(V)_.

Далее начнём алгоритм с какой-то вершины и для каждого ребра данной вершины, изменим вес соседней вершины, соединённой с данной этим рёбром, и вершину, и вторую вершину, если текущий вес меньше хранимого веса в данной вершине (данная операция выполняется за _О(1)_. Далее извлекаем минимальный элемент из кучи (_O(log V)_) и добавляем вершину в остовное дерево. После рассматриваем добавленную вершину как текущую и повторяем операцию пока все вершины не будут в остовном дереве.

Всего мы рассмотрим _E_ рёбер с операцией обновления за _O(1)_ и _V_ операций удаления минимума из кучи за _O(log V)_.

##### Сложность

Сложность такого алгоритма будет _O(V)_ - на инициализацию + _O(E * 1)_ - на обновление веса ребёр + _O(V * log V)_ - на извлечения минимума из кучи.

Итого: _O(V + E + V * log V) = O(E + V * log V)_.

##### Code

```python
def fibonacci_heap_mst(graph):
    fheap = FibonacciHeap()
    nodes = {}
    mst_weight = 0
    edges = []
    mst = set()
    for v in graph:
        nodes[v] = fheap.insert((float('inf'), -1, -1))

    next_vert = next(iter(graph.keys()))
    mst.add(next_vert)
    while len(mst) < len(graph):
        v = next_vert
        for vert, weight in graph[v]:
            if vert not in mst:
                fheap.decrease_key(nodes[vert], (weight, v, vert))

        weight, v1, v2 = fheap.extract_min().key
        next_vert = v2
        mst.add(v2)
        edges.append((v1, v2))
        mst_weight += weight

    return edges, mst_weight
```